#### Dynamic Programming
##### Fibonacci
- Recursion:
  ```python
  def fib(n):
    if n<=2:
      return 1
    else:
      f = fib(n-1)+fib(n-2)
      return f
  ```
  时间复杂度 O(2^N), 因为:  
  T(n) = T(n-1)+T(n-2)+o(1)  
  下限为:  
  T(n) >= 2 * T(n-2)  
  Thus, the time complexity is exponential.

- Memorized
```python
  momo = {}
  def fib(n):
    if n in memo:
      return memo[n]
    if n <=2:
      return 1
    else:
      f = fib(n-1)+fib(n-2)
      memo[n] = f
      return f
```
应用这种思路后，在我们计算完T(n-1)之后，我们已经计算过了T(n-2)，我们不必要再算一次。由此可见，动态规划其实就是recursion加上memoize。
- **DP中的重点问题就是找到什么是subproblem.**
- Bottom up
```python
def fib(n):
    fib={}
    for k in range(1,n+1):
      if k<=2:
        fib[k] = 1
      else:
        fib[k] = fib[k-1]+fib[k-2]
    return fib[n]
```
使用这个思路，由于应用了一个for循环，所以实际是从fib（1）开始计算，由小到大计算出了结果，由此可以保证在计算fib（n）的时候一定已经计算过了fib（n-1）和fib（n-2）  
这种思路的另一个优点是，可以只存储最近的两个值，因为我们实际上只需要最近的两个值.

##### Shortest Path

-  采用memoize

```python
  distance = {}
  def shortest(v):
      if v in distance:
          return distance[v]
     	else:
          ulst = getlast(v)
          templst []
          for u in ulst:
              templst.append(shortest(u)+getdistance(u,v))
          distance[v] = min(templst)
          return distance[v]
```

  但是这种方法有可能因为图中有环而陷入无限循环,可以采用分层的方法去掉存在的环（见ＭＩＴ视频最后六分钟左右）

##### 5 Easy steps to DP

- define subproblems
- guess (part of solution)
- relate subproblem solutions
- recurse &memoize(build DP table bottom up)
- solve the original problem
  0-1背包问题

对于最简单的0-1背包问题，规定数组C中存储了每个物品所占体积，W中存储了每个物品的价值，背包总的体积为V。

我们需要一个二维数组两个维度分别长度为N（物品数量）和V（总体积），每个单元格中存储的是前n件物品放入体积为v的背包中能够达到的最大价值。其实我们最终的需求是求出（N，V）这个格子的值，但是想要求出这个值，我们需要借助其余的单元格进行推导。而我们不需要比V更多的单元格，因为那不是我们这个问题最终要考虑的问题。

首先分解出子问题的转移方程：

```python
f[i][v]=max(f[i-1][v],f[i-1][v-c[i]]+w[i])
```

第i个单元格中的值，是取决于两种情况中的最大者，第一：不放入当前的第i件物品，那么结果也就是，仍把当前的v留给剩下的i-1件物品，由此能够得到的最大价值。第二：放入当前物品，那么结果也就是，将v减去当前物品体积所剩余的空间留给i-1件物品所能够得到的最大值加上当前物品的价值。

由此转移方程我们可以写出最基础的两层循环结构：

```
for i=1..N
    for v=0...V
        f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]};
```
>>>>>>> 3ec8a5271a2c67f69bb460f4282161a9924b86e5

此时的时间和空间复杂度均为O（VN），对于这一情况我们只能对空间复杂度继续优化，我们将二维的数组缩减为一个一维的长度为V的数组，这样衍生出的问题就是，我们如何能够保证这个数组在经历了第i轮循环之后保存的值是原有二维数组的第i行。在我们计算第i轮的循环中的结果时，我们需要用到i-1轮的计算结果。那么这个空间优化问题可以转化为，如何能做到使第i轮的结果和第i-1轮的结果在一个一维数组中共存。我们采用倒叙遍历即可实现：

```
for i=1..N
    for v=V..0
        f[v]=max{f[v],f[v-c[i]]+w[i]};
```

由上可以看出，当我们从V开始计算第i轮的结果，我们需要用到的是，当前数组的第V项，以及当前数组的第V-c【i】项，因为我们是倒叙遍历，因此第V-c【i】项仍是i-1轮的结果，它仍然还没有被更新。同时我们利用了一个重要特性，那就是，在第i轮计算第v项的时候，我们不会用到（v，V）这些单元格中的结果。由此我们就实现空间上的优化。需要注意的一点是，我们仅仅是改变了遍历V的方式，外层的循环仍然是自上而下的顺序1...N。

为了后续使用方便，我们抽象出一个处理一件物品的过程：

过程ZeroOnePack，表示处理一件01背包中的物品，两个参数cost、weight分别表明这件物品的费用和价值。

```
procedure ZeroOnePack(cost,weight)
    for v=V..cost
        f[v]=max{f[v],f[v-cost]+weight}
```

在此处我们可以注意到，循环的条件变成了V...cost，这是因为对于一件体积为cost 的物品，容积小于cost的背包是装不下的，因此我们也就不用考虑这件物品对这些容积小于cost的背包所能容纳的物品价值的影响，由此进一步简化了运算。由此可以将基础循环改为如下格式：

```
for i=1..N
    ZeroOnePack(c[i],w[i]);
```

- 恰好装满的背包问题：

  对于求恰好装满的最大值问题，在初始化时，f【v】除了第一项，其余均设置为-inf，这样就可以保证最后的结果。

  其中的道理就是，如上初始化，在第一轮中，假设物品的价值是5，体积是3，那么经历了第一轮循环后，只有f【3】会出现非负无穷的常数值，

  ```python
  f_init = [0,-inf,-inf,-inf,-inf,-inf]
  f_after = [0,-inf,-inf,5,-inf,-inf]
  ```

  因为在计算f【3】时，max（f【3】，f【3-3】+5）f【3】之前的值为-inf，而f（0）的值为0，由此可以成功赋值5.对于其他位置的单元格：不放入的情况上一轮的结果是-inf，如果放入那么剩余v-c【i】这个格子的结果是-inf+5仍为-inf，所以本轮的结果还是-inf。由此就可以实现每一轮出现的常数值，都是恰好装满某个容积的背包所对应的价值。！！！！！！！！！！！！！！！！！！！！！！！！！！！！（太特么巧妙了。。。。。。。。。。）

  恰好装满的最大值： ![Alt](./IMG_4774.JPG)

  恰好装满的最小值：![Alt](./IMG_4775.JPG)

  两种情况的对比![Alt](./IMG_4776.JPG)

  ​

##### 完全背包问题

完全背包问题不再考虑每个物品的数量，也就是说每个物品都可以被无限次放入背包，由此循环到每一个物品的时候更新公式变成了下式：

```
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}
```

其中|号后面的部分表示取所有满足后面不等式的k放入列表。由于每一次的选项不止两个（放或不放），而变成了可以放最多K个，因此求解每一个状态的时间增长到了O(v/c[i])。

- 简化1:筛选出物美价廉的物品

  也就是说，针对所有i，j如果i的体积比j小同时价值大于j，那么我们将不考虑j这件物品。因为更多的放入i不仅更省空间而且可以获得更大价值。

  这个优化的具体过程可以通过简单的N^2循环来实现。

- 简化2:将每一个物品拆解为V/c【i】件物品，然后将问题转化为0-1背包问题。

  这样做其实仅仅是实现了逻辑思维上的简化，从代码的时间复杂度上来说，并没有区别。

- 简化3:从cost到V顺叙遍历

  ```
  F[i,v] = max(F[i − 1,v],F[i,v − Ci] + Wi)
  ```

  之所以逆序遍历就是因为在0-1背包中，每个物品只能放置一次，因此在计算第i个物品放入容积为v的背包这个步骤时，我们需要知道的是前i-1个物品放入v-c【i】这个背包的最大价值。而现在面临的完全背包问题中，我们可以反复放置同一个物品，因此改为顺序遍历，从cost开始，就可以至少放一次当前的第i个物品了，因此在计算第i个物品放入容积为v的背包这个步骤时，我们需要的v-c【i】这个单元格中的价值有可能已经放置了若干次第i个物品（也有可能没有放置）。

  **太特么巧妙了！！！！！！！！！！！！！啊！！！！！！！！！！！！！！！**

  ​









